1.- falso , si fuese sin mejora seria cierto

2.- V

3.- Faslo , se define como una lista de listas

4.- V

5.- V , Si en el caso anterior el operador < ya esta usandose para otro tipo de ordenacion sobre Clase A , entonces se puede usar la definicion : set siendo comparaClaseA una clase de comparacion para Clase A→V

6.- V , pq permite no salirnos de la tabla de dispersion 

7.- V

8.- Falso no sabemos el tamaño de las tablas

9.- V

10.-F `vector <List <Entrada<T> >` , pq iban añadiendo las colisiones en la lista

11.- V

12.- V

13,. F

14.-V

15.- F, solo la dispersion doble permite evitar los 2 tipos de agrupamientos

16.- V

17.- V

18.- V , puede ser que una cubeta de tamaño 5 se ha llenado pero luego se quitan datos . Porque se marca de por vida
19.- V 
20 .- F
21.- f , por el tiempo constante
22.- →v , es adaptativo
23.- V
24.- falso , deberia ser 1x8 . osea un nodo y 8 hijos
25.-F , El hhd y flash seria alrevez
26.- falso esta casi todo bien pero no se habla del bloque del ordenador . lo correcto seria el tamaño de bloque de transmision del sistema operativo .
27.- falso , es alrevez
28.-v
29.-falso es un numero determinado
30.- V lo hace automaticamente 

31.- v , se puede hacer sobre el mismo fichero pero no es practico sique no se

32.- F , se establece sobre el indice en memoria y cuando se cierra la aplicacion se guarda

33.-F es acceso a RAM

34.-  V 

35.- F

36.-Falso , se reconstruie si uno se da cuenta si esta corrupto sino es solamente cargarlo en ram no reconstruirlo

37.-  v , un dato cuando no es clave puede tener repetido

38.- Falso , los arboles B estan siempre en fichero y uno de los nodos llevamos a la ram para ir evaluandolo . lo otro en cierta medida es cierto

39.- V , pq en un arbol B es importante el orden que llegan los valores
40.- Falso , nada tiene que ver con rotaciones
41.-     -   Verdadero
    -   4 Niveles = 5^4 maximo = pero como cada caja es de 5 necesitamos minimo 3 por caja
    -   nivel 1 = 5 maximo = 3 minimo
    -   nivel 2 = 25 maximo = 5*3 =15 minimo
    -   nivel 3 = 125 maximo = 25*3 =75 minimo
    -   nivel 4 = 625 maximo=125*3 = 375 min
42.- Falso talvez no lo se lol  ,En el borra se pueden cambiar de lugar pero en el inserta se puede repartir la carga osea se crea otro nodo
43.- Falso , es una matriz dinamica . esta en el heap
44.- falso , existen las tabla hash que lo permiten
45.- v , si fuese el borra no 
46.- falso no tiene nada al principio. si fuese solo v.begin()sin el +5 entonces si se podria
47.- V
48.- v , a nivel de representacion
49.- Verdadero el grid es una malla y funciona bien si los puntos se reparten bien
50.- Falso , en la lista no cambia de sitio
51.- Verdadero

52.-verdadero busca minimizar el numero de colisiones

53.- v
54.- v , si fuese un vector
55.- Falso , las composicion pueden ser con o sin punteros
56.- Falso, la union sera maximo de 15+7 bits si no se repite niguno . y como minimo seria el caso cuando se repiten 7 y seria 7 +(15-7) = 15.

57.- verdadero

58,.verdadero , se puede hacer un arbol ABB con solo hijos a la izquierda y se elimina los primeros .
59.- Falso , no es viable hacer iteracion en las tabla hash

60.- V
61.- falso , como minimmo

62.-V
63.F falta un & para que sea de lectura y escritura sino seria solo de lectura
64.- Falso , en las asociaciones solo apuntamos no borramos
65.- V
66.-Falso , un grafo no es eficiente con un vector de listas
67.- falso
68.- V
69.- F
70.-
71.- V
72.-F
73.- V
74.- F
75.- F
76.-
77.-V
78.-F
79.-V
80.-V
81.-F
82.-F
83.-F, si debe cumplir esta propiedad pero tambien debe cumplir que este distrubuido adecuadamente por ejemplo si solo tiene hijos derechos sera lineal
84.-V
85.- V
86.-V
87.-F
88.-F , seria heap overfloqw
89.-F a 1/3
90.- V
91.- F seria O(1)
92.-  V
93.-Falso , 5
94.- V
